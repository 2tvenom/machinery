<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Machinery by RichardKnop</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Machinery</h1>
      <h2 class="project-tagline">Machinery is an asynchronous task queue/job queue based on distributed message passing.</h2>
      <a href="https://github.com/RichardKnop/machinery" class="btn">View on GitHub</a>
      <a href="https://github.com/RichardKnop/machinery/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/RichardKnop/machinery/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p><a href="http://godoc.org/github.com/RichardKnop/machinery/v1"><img src="https://img.shields.io/badge/godoc-reference-blue.svg" alt="GoDoc" title="GoDoc"></a>
<img src="https://travis-ci.org/RichardKnop/machinery.svg?branch=master" alt="Build Status"></p>

<h1>
<a id="machinery" class="anchor" href="#machinery" aria-hidden="true"><span class="octicon octicon-link"></span></a>Machinery</h1>

<p>Machinery is an asynchronous task queue/job queue based on distributed message passing.</p>

<p>So called tasks (or jobs if you like) are executed concurrently either by many workers on many servers or multiple worker processes on a single server using Golang's goroutines.</p>

<p>This is an early stage project so far. Feel free to contribute.</p>

<ul>
<li><a href="https://github.com/RichardKnop/machinery#first-steps">First Steps</a></li>
<li><a href="https://github.com/RichardKnop/machinery#configuration">Configuration</a></li>
<li><a href="https://github.com/RichardKnop/machinery#server">Server</a></li>
<li><a href="https://github.com/RichardKnop/machinery#workers">Workers</a></li>
<li>
<a href="https://github.com/RichardKnop/machinery#tasks">Tasks</a>

<ul>
<li><a href="https://github.com/RichardKnop/machinery#registering-tasks">Registering Tasks</a></li>
<li><a href="https://github.com/RichardKnop/machinery#signatures">Signatures</a></li>
<li><a href="https://github.com/RichardKnop/machinery#supported-types">Supported Types</a></li>
<li><a href="https://github.com/RichardKnop/machinery#sending-tasks">Sending Tasks</a></li>
<li><a href="https://github.com/RichardKnop/machinery#keeping-results">Keeping Results</a></li>
</ul>
</li>
<li>
<a href="https://github.com/RichardKnop/machinery#workflows">Workflows</a>

<ul>
<li><a href="https://github.com/RichardKnop/machinery#groups">Groups</a></li>
<li><a href="https://github.com/RichardKnop/machinery#chords">Chords</a></li>
<li><a href="https://github.com/RichardKnop/machinery#chains">Chains</a></li>
</ul>
</li>
<li><a href="https://github.com/RichardKnop/machinery#development-setup">Development Setup</a></li>
</ul>

<h2>
<a id="first-steps" class="anchor" href="#first-steps" aria-hidden="true"><span class="octicon octicon-link"></span></a>First Steps</h2>

<p>Add the Machinery library to your $GOPATH/src:</p>

<pre><code>$ go get github.com/RichardKnop/machinery
</code></pre>

<p>Install dependencies:</p>

<pre><code>$ make deps
</code></pre>

<p>First, you will need to define some tasks. Look at sample tasks in <code>_examples/tasks/tasks.go</code> to see few examples.</p>

<p>Second, you will need to launch a worker process:</p>

<pre><code>$ go run _examples/worker/worker.go
</code></pre>

<p><img src="https://raw.githubusercontent.com/RichardKnop/machinery/master/assets/example_worker.png" alt="Example worker"></p>

<p>Finally, once you have a worker running and waiting for tasks to consume, send some tasks:</p>

<pre><code>$ go run _examples/send/send.go
</code></pre>

<p>You will be able to see the tasks being processed asynchronously by the worker:</p>

<p><img src="https://raw.githubusercontent.com/RichardKnop/machinery/master/assets/example_worker_receives_tasks.png" alt="Example worker receives tasks"></p>

<h2>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configuration</h2>

<p>Machinery has several configuration options. Configuration is encapsulated by a <code>Config</code> struct and injected as a dependency to objects that need it.</p>

<div class="highlight highlight-go"><pre><span class="pl-k">type</span> <span class="pl-v">Config</span> <span class="pl-k">struct</span> {
    <span class="pl-v">Broker</span>          <span class="pl-k">string</span> <span class="pl-s"><span class="pl-pds">`</span>yaml:"broker"<span class="pl-pds">`</span></span>
    <span class="pl-v">ResultBackend</span>   <span class="pl-k">string</span> <span class="pl-s"><span class="pl-pds">`</span>yaml:"result_backend"<span class="pl-pds">`</span></span>
    <span class="pl-v">ResultsExpireIn</span> <span class="pl-k">int</span>    <span class="pl-s"><span class="pl-pds">`</span>yaml:"results_expire_in"<span class="pl-pds">`</span></span>
    <span class="pl-v">Exchange</span>        <span class="pl-k">string</span> <span class="pl-s"><span class="pl-pds">`</span>yaml:"exchange"<span class="pl-pds">`</span></span>
    <span class="pl-v">ExchangeType</span>    <span class="pl-k">string</span> <span class="pl-s"><span class="pl-pds">`</span>yaml:"exchange_type"<span class="pl-pds">`</span></span>
    <span class="pl-v">DefaultQueue</span>    <span class="pl-k">string</span> <span class="pl-s"><span class="pl-pds">`</span>yaml:"default_queue"<span class="pl-pds">`</span></span>
    <span class="pl-v">BindingKey</span>      <span class="pl-k">string</span> <span class="pl-s"><span class="pl-pds">`</span>yaml:"binding_key"<span class="pl-pds">`</span></span>
}</pre></div>

<h3>
<a id="broker" class="anchor" href="#broker" aria-hidden="true"><span class="octicon octicon-link"></span></a>Broker</h3>

<p>A message broker. Currently supported brokers are:</p>

<ul>
<li>AMQP (use AMQP URL such as <code>amqp://guest:guest@localhost:5672/</code>)</li>
<li>Redis (use Redis URL such as <code>redis://127.0.0.1:6379</code>)</li>
</ul>

<h3>
<a id="resultbackend" class="anchor" href="#resultbackend" aria-hidden="true"><span class="octicon octicon-link"></span></a>ResultBackend</h3>

<p>Result backend to use for keeping task states and results. This setting is optional, you can run Machinery without keeping track of task results.</p>

<p>Currently supported backends are:</p>

<ul>
<li>Redis (use Redis URL such as <code>redis://127.0.0.1:6379</code>)</li>
<li>Memcache (use Memcache URL such as <code>memcache://10.0.0.1:11211,10.0.0.2:11211</code>)</li>
<li>AMQP (use AMQP URL such as <code>amqp://guest:guest@localhost:5672/</code>)</li>
</ul>

<blockquote>
<p>Keep in mind AMQP is not recommended as a result backend. See <a href="https://github.com/RichardKnop/machinery#keeping-results">Keeping Results</a></p>
</blockquote>

<h3>
<a id="resultsexpirein" class="anchor" href="#resultsexpirein" aria-hidden="true"><span class="octicon octicon-link"></span></a>ResultsExpireIn</h3>

<p>How long to store task results for in seconds. Defaults to 3600 (1 hour).</p>

<h3>
<a id="exchange" class="anchor" href="#exchange" aria-hidden="true"><span class="octicon octicon-link"></span></a>Exchange</h3>

<p>Exchange name, e.g. <code>machinery_exchange</code>. Only required for AMQP.</p>

<h3>
<a id="exchangetype" class="anchor" href="#exchangetype" aria-hidden="true"><span class="octicon octicon-link"></span></a>ExchangeType</h3>

<p>Exchange type, e.g. <code>direct</code>. Only required for AMQP.</p>

<h3>
<a id="defaultqueue" class="anchor" href="#defaultqueue" aria-hidden="true"><span class="octicon octicon-link"></span></a>DefaultQueue</h3>

<p>Default queue name, e.g. <code>machinery_tasks</code>.</p>

<h3>
<a id="bindingkey" class="anchor" href="#bindingkey" aria-hidden="true"><span class="octicon octicon-link"></span></a>BindingKey</h3>

<p>The queue is bind to the exchange with this key, e.g. <code>machinery_task</code>. Only required for AMQP.</p>

<h2>
<a id="server" class="anchor" href="#server" aria-hidden="true"><span class="octicon octicon-link"></span></a>Server</h2>

<p>A Machinery library must be instantiated before use. The way this is done is by creating a <code>Server</code> instance. <code>Server</code> is a base object which stores Machinery configuration and registered tasks. E.g.:</p>

<div class="highlight highlight-go"><pre>
<span class="pl-k">import</span> (
    <span class="pl-s"><span class="pl-pds">"</span>github.com/RichardKnop/machinery/v1/config<span class="pl-pds">"</span></span>
    machinery <span class="pl-s"><span class="pl-pds">"</span>github.com/RichardKnop/machinery/v1<span class="pl-pds">"</span></span>
)

<span class="pl-k">var</span> <span class="pl-smi">cnf</span> = config.<span class="pl-smi">Config</span>{
    <span class="pl-v">Broker</span>:        <span class="pl-s"><span class="pl-pds">"</span>amqp://guest:guest@localhost:5672/<span class="pl-pds">"</span></span>,
    <span class="pl-v">ResultBackend</span>: <span class="pl-s"><span class="pl-pds">"</span>amqp://guest:guest@localhost:5672/<span class="pl-pds">"</span></span>,
    <span class="pl-v">Exchange</span>:      <span class="pl-s"><span class="pl-pds">"</span>machinery_exchange<span class="pl-pds">"</span></span>,
    <span class="pl-v">ExchangeType</span>:  <span class="pl-s"><span class="pl-pds">"</span>direct<span class="pl-pds">"</span></span>,
    <span class="pl-v">DefaultQueue</span>:  <span class="pl-s"><span class="pl-pds">"</span>machinery_tasks<span class="pl-pds">"</span></span>,
    <span class="pl-v">BindingKey</span>:    <span class="pl-s"><span class="pl-pds">"</span>machinery_task<span class="pl-pds">"</span></span>,
}

<span class="pl-smi">server</span>, <span class="pl-smi">err</span> <span class="pl-k">:=</span> machinery.<span class="pl-c1">NewServer</span>(&amp;cnf)
<span class="pl-k">if</span> err != <span class="pl-c1">nil</span> {
    <span class="pl-c">// do something with the error</span>
}</pre></div>

<h2>
<a id="workers" class="anchor" href="#workers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Workers</h2>

<p>In order to consume tasks, you need to have one or more workers running. All you need to run a worker is a <code>Server</code> instance with registered tasks. E.g.:</p>

<div class="highlight highlight-go"><pre><span class="pl-smi">worker</span> <span class="pl-k">:=</span> server.<span class="pl-c1">NewWorker</span>(<span class="pl-s"><span class="pl-pds">"</span>worker_name<span class="pl-pds">"</span></span>)
<span class="pl-smi">err</span> <span class="pl-k">:=</span> worker.<span class="pl-c1">Launch</span>()
<span class="pl-k">if</span> err != <span class="pl-c1">nil</span> {
    <span class="pl-c">// do something with the error</span>
}</pre></div>

<p>Each worker will only consume registered tasks.</p>

<h2>
<a id="tasks" class="anchor" href="#tasks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tasks</h2>

<p>Tasks are a building block of Machinery applications. A task is a function which defines what happens when a worker receives a message. Let's say we want to define tasks for adding and multiplying numbers:</p>

<div class="highlight highlight-go"><pre><span class="pl-k">func</span> <span class="pl-en">Add</span>(<span class="pl-v">args</span> ...<span class="pl-v">int64</span>) (<span class="pl-v">int64</span>, <span class="pl-v">error</span>) {
    <span class="pl-smi">sum</span> <span class="pl-k">:=</span> <span class="pl-c1">int64</span>(<span class="pl-c1">0</span>)
    <span class="pl-k">for</span> <span class="pl-smi">_</span>, <span class="pl-smi">arg</span> <span class="pl-k">:=</span> <span class="pl-k">range</span> args {
        sum += arg
    }
    <span class="pl-k">return</span> sum, <span class="pl-c1">nil</span>
}

<span class="pl-k">func</span> <span class="pl-en">Multiply</span>(<span class="pl-v">args</span> ...<span class="pl-v">int64</span>) (<span class="pl-v">int64</span>, <span class="pl-v">error</span>) {
    <span class="pl-smi">sum</span> <span class="pl-k">:=</span> <span class="pl-c1">int64</span>(<span class="pl-c1">1</span>)
    <span class="pl-k">for</span> <span class="pl-smi">_</span>, <span class="pl-smi">arg</span> <span class="pl-k">:=</span> <span class="pl-k">range</span> args {
        sum *= arg
    }
    <span class="pl-k">return</span> sum, <span class="pl-c1">nil</span>
}</pre></div>

<h3>
<a id="registering-tasks" class="anchor" href="#registering-tasks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Registering Tasks</h3>

<p>Before your workers can consume a task, you need to register it with the server. This is done by assigning a task a unique name:</p>

<div class="highlight highlight-go"><pre>server.<span class="pl-c1">RegisterTasks</span>(<span class="pl-k">map</span>[<span class="pl-k">string</span>]<span class="pl-k">interface</span>{}{
    <span class="pl-s"><span class="pl-pds">"</span>add<span class="pl-pds">"</span></span>:      <span class="pl-v">Add</span>,
    <span class="pl-s"><span class="pl-pds">"</span>multiply<span class="pl-pds">"</span></span>: <span class="pl-v">Multiply</span>,
})</pre></div>

<p>Task can also be registered one by one:</p>

<div class="highlight highlight-go"><pre>server.<span class="pl-c1">RegisterTask</span>(<span class="pl-s"><span class="pl-pds">"</span>add<span class="pl-pds">"</span></span>, <span class="pl-v">Add</span>)
server.<span class="pl-c1">RegisterTask</span>(<span class="pl-s"><span class="pl-pds">"</span>multiply<span class="pl-pds">"</span></span>, <span class="pl-v">Multiply</span>)</pre></div>

<p>Simply put, when a worker receives a message like this:</p>

<div class="highlight highlight-json"><pre>{
    <span class="pl-s"><span class="pl-pds">"</span>UUID<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>48760a1a-8576-4536-973b-da09048c2ac5<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>Name<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>add<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>RoutingKey<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>GroupUUID<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>GroupTaskCount<span class="pl-pds">"</span></span>: <span class="pl-c1">0</span>,
    <span class="pl-s"><span class="pl-pds">"</span>Args<span class="pl-pds">"</span></span>: [
        {
            <span class="pl-s"><span class="pl-pds">"</span>Type<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>Value<span class="pl-pds">"</span></span>: <span class="pl-c1">1</span>,
        },
        {
            <span class="pl-s"><span class="pl-pds">"</span>Type<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>Value<span class="pl-pds">"</span></span>: <span class="pl-c1">1</span>,
        }
    ],
    <span class="pl-s"><span class="pl-pds">"</span>Immutable<span class="pl-pds">"</span></span>: <span class="pl-c1">false</span>,
    <span class="pl-s"><span class="pl-pds">"</span>OnSuccess<span class="pl-pds">"</span></span>: <span class="pl-c1">null</span>,
    <span class="pl-s"><span class="pl-pds">"</span>OnError<span class="pl-pds">"</span></span>: <span class="pl-c1">null</span>,
    <span class="pl-s"><span class="pl-pds">"</span>ChordCallback<span class="pl-pds">"</span></span>: <span class="pl-c1">null</span>
}</pre></div>

<p>It will call Add(1, 1). Each task should return an error as well so we can handle failures.</p>

<p>Ideally, tasks should be idempotent which means there will be no unintended consequences when a task is called multiple times with the same arguments.</p>

<h3>
<a id="signatures" class="anchor" href="#signatures" aria-hidden="true"><span class="octicon octicon-link"></span></a>Signatures</h3>

<p>A signature wraps calling arguments, execution options (such as immutability) and success/error callbacks of a task so it can be sent across the wire to workers. Task signatures implement a simple interface:</p>

<div class="highlight highlight-go"><pre><span class="pl-k">type</span> <span class="pl-v">TaskArg</span> <span class="pl-k">struct</span> {
    <span class="pl-v">Type</span>  <span class="pl-k">string</span>
    <span class="pl-v">Value</span> <span class="pl-k">interface</span>{}
}

<span class="pl-k">type</span> <span class="pl-v">TaskSignature</span> <span class="pl-k">struct</span> {
    <span class="pl-v">UUID</span>           <span class="pl-k">string</span>
    <span class="pl-v">Name</span>           <span class="pl-k">string</span>
    <span class="pl-v">RoutingKey</span>     <span class="pl-k">string</span>
    <span class="pl-v">GroupUUID</span>      <span class="pl-k">string</span>
    <span class="pl-v">GroupTaskCount</span> <span class="pl-k">int</span>
    <span class="pl-v">Args</span>           []<span class="pl-v">TaskArg</span>
    <span class="pl-v">Immutable</span>      <span class="pl-k">bool</span>
    <span class="pl-v">OnSuccess</span>      []*TaskSignature
    <span class="pl-v">OnError</span>        []*TaskSignature
    <span class="pl-v">ChordCallback</span>  *TaskSignature
}</pre></div>

<p><code>UUID</code> is a unique ID of a task. You can either set it yourself or it will be automatically generated.</p>

<p><code>Name</code> is the unique task name by which it is registered against a Server instance.</p>

<p><code>RoutingKey</code> is used for routing a task to correct queue. If you leave it empty, the default behaviour will be to set it to the default queue's binding key for direct exchange type and to the default queue name for other exchange types.</p>

<p><code>GroupUUID</code>, GroupTaskCount are useful for creating groups of tasks.</p>

<p><code>Args</code> is a list of arguments that will be passed to the task when it is executed by a worker.</p>

<p><code>Immutable</code> is a flag which defines whether a result of the executed task can be modified or not. This is important with <code>OnSuccess</code> callbacks. Immutable task will not pass its result to its success callbacks while a mutable task will prepend its result to args sent to callback tasks. Long story short, set Immutable to false if you want to pass result of the first task in a chain to the second task.</p>

<p><code>OnSuccess</code> defines tasks which will be called after the task has executed successfully. It is a slice of task signature structs.</p>

<p><code>OnError</code> defines tasks which will be called after the task execution fails. The first argument passed to error callbacks will be the error returned from the failed task.</p>

<p><code>ChordCallback</code> is used to create a callback to a group of tasks.</p>

<h3>
<a id="supported-types" class="anchor" href="#supported-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Supported Types</h3>

<p>Machinery encodes tasks to JSON before sending them to the broker. Task results are also stored in the backend as JSON encoded strings. Therefor only types with native JSON representation can be supported. Currently supported types are:</p>

<ul>
<li><code>bool</code></li>
<li><code>int</code></li>
<li><code>int8</code></li>
<li><code>int16</code></li>
<li><code>int32</code></li>
<li><code>int64</code></li>
<li><code>unint</code></li>
<li><code>uint8</code></li>
<li><code>uint16</code></li>
<li><code>uint32</code></li>
<li><code>uint64</code></li>
<li><code>float32</code></li>
<li><code>float64</code></li>
<li><code>string</code></li>
</ul>

<h3>
<a id="sending-tasks" class="anchor" href="#sending-tasks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sending Tasks</h3>

<p>Tasks can be called by passing an instance of <code>TaskSignature</code> to an <code>Server</code> instance. E.g:</p>

<div class="highlight highlight-go"><pre><span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">"</span>github.com/RichardKnop/machinery/v1/signatures<span class="pl-pds">"</span></span>

<span class="pl-smi">task</span> <span class="pl-k">:=</span> signatures.<span class="pl-smi">TaskSignature</span>{
    <span class="pl-v">Name</span>: <span class="pl-s"><span class="pl-pds">"</span>add<span class="pl-pds">"</span></span>,
    <span class="pl-v">Args</span>: []signatures.<span class="pl-smi">TaskArg</span>{
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">1</span>,
        },
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">1</span>,
        },
    },
}

<span class="pl-smi">asyncResult</span>, <span class="pl-smi">err</span> <span class="pl-k">:=</span> server.<span class="pl-c1">SendTask</span>(&amp;task1)
<span class="pl-k">if</span> err != <span class="pl-c1">nil</span> {
    <span class="pl-c">// failed to send the task</span>
    <span class="pl-c">// do something with the error</span>
}</pre></div>

<h3>
<a id="keeping-results" class="anchor" href="#keeping-results" aria-hidden="true"><span class="octicon octicon-link"></span></a>Keeping Results</h3>

<p>If you configure a result backend, the task states and results will be persisted. Possible states:</p>

<div class="highlight highlight-go"><pre><span class="pl-k">const</span> (
    <span class="pl-v">PendingState</span>  = <span class="pl-s"><span class="pl-pds">"</span>PENDING<span class="pl-pds">"</span></span>
    <span class="pl-v">ReceivedState</span> = <span class="pl-s"><span class="pl-pds">"</span>RECEIVED<span class="pl-pds">"</span></span>
    <span class="pl-v">StartedState</span>  = <span class="pl-s"><span class="pl-pds">"</span>STARTED<span class="pl-pds">"</span></span>
    <span class="pl-v">SuccessState</span>  = <span class="pl-s"><span class="pl-pds">"</span>SUCCESS<span class="pl-pds">"</span></span>
    <span class="pl-v">FailureState</span>  = <span class="pl-s"><span class="pl-pds">"</span>FAILURE<span class="pl-pds">"</span></span>
)</pre></div>

<blockquote>
<p>When using AMQP as a result backend, task states will be persisted in separate queues for each task. Although RabbitMQ can scale up to thousands of queues, it is strongly advised to use a better suited result backend (e.g. Memcache) when you are expecting to run a large number of parallel tasks.</p>
</blockquote>

<div class="highlight highlight-go"><pre><span class="pl-k">type</span> <span class="pl-v">TaskResult</span> <span class="pl-k">struct</span> {
    <span class="pl-v">Type</span>  <span class="pl-k">string</span>
    <span class="pl-v">Value</span> <span class="pl-k">interface</span>{}
}

<span class="pl-k">type</span> <span class="pl-v">TaskState</span> <span class="pl-k">struct</span> {
    <span class="pl-v">TaskUUID</span> <span class="pl-k">string</span>
    <span class="pl-v">State</span>    <span class="pl-k">string</span>
    <span class="pl-v">Result</span>   *TaskResult
    <span class="pl-v">Error</span>    <span class="pl-k">string</span>
}

<span class="pl-k">type</span> <span class="pl-v">TaskStateGroup</span> <span class="pl-k">struct</span> {
    <span class="pl-v">GroupUUID</span>      <span class="pl-k">string</span>
    <span class="pl-v">GroupTaskCount</span> <span class="pl-k">int</span>
    <span class="pl-v">States</span>         <span class="pl-k">map</span>[<span class="pl-k">string</span>]TaskState
}</pre></div>

<p><code>TaskResult</code> represents a return value of a processed task.</p>

<p><code>TaskState</code> struct will be serialized and stored every time a task state changes.</p>

<p><code>TaskStateGroup</code> is used for keeping a state of group of tasks.</p>

<p><code>AsyncResult</code> object allows you to check for the state of a task:</p>

<div class="highlight highlight-go"><pre><span class="pl-smi">taskState</span> <span class="pl-k">:=</span> asyncResult.<span class="pl-c1">GetState</span>()
fmt.<span class="pl-c1">Printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Current state of <span class="pl-c1">%v</span> task is:<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, taskState.<span class="pl-smi">TaskUUID</span>)
fmt.<span class="pl-c1">Println</span>(taskState.<span class="pl-smi">State</span>)</pre></div>

<p>There are couple of convenient me methods to inspect the task status:</p>

<div class="highlight highlight-go"><pre>asyncResult.<span class="pl-c1">GetState</span>().<span class="pl-c1">IsCompleted</span>()
asyncResult.<span class="pl-c1">GetState</span>().<span class="pl-c1">IsSuccess</span>()
asyncResult.<span class="pl-c1">GetState</span>().<span class="pl-c1">IsFailure</span>()</pre></div>

<p>You can also do a synchronous blocking call to wait for a task result:</p>

<div class="highlight highlight-go"><pre><span class="pl-smi">result</span>, <span class="pl-smi">err</span> <span class="pl-k">:=</span> asyncResult.<span class="pl-c1">Get</span>()
<span class="pl-k">if</span> err != <span class="pl-c1">nil</span> {
    <span class="pl-c">// getting result of a task failed</span>
    <span class="pl-c">// do something with the error</span>
}
fmt.<span class="pl-c1">Println</span>(result.<span class="pl-c1">Interface</span>())</pre></div>

<h2>
<a id="workflows" class="anchor" href="#workflows" aria-hidden="true"><span class="octicon octicon-link"></span></a>Workflows</h2>

<p>Running a single asynchronous task is fine but often you will want to design a workflow of tasks to be executed in an orchestrated way. There are couple of useful functions to help you design workflows.</p>

<h3>
<a id="groups" class="anchor" href="#groups" aria-hidden="true"><span class="octicon octicon-link"></span></a>Groups</h3>

<p><code>Group</code> is a set of tasks which will be executed in parallel, independent of each other. E.g.:</p>

<div class="highlight highlight-go"><pre><span class="pl-k">import</span> (
    <span class="pl-s"><span class="pl-pds">"</span>github.com/RichardKnop/machinery/v1/signatures<span class="pl-pds">"</span></span>
    machinery <span class="pl-s"><span class="pl-pds">"</span>github.com/RichardKnop/machinery/v1<span class="pl-pds">"</span></span>
)

<span class="pl-smi">task1</span> <span class="pl-k">:=</span> signatures.<span class="pl-smi">TaskSignature</span>{
    <span class="pl-v">Name</span>: <span class="pl-s"><span class="pl-pds">"</span>add<span class="pl-pds">"</span></span>,
    <span class="pl-v">Args</span>: []signatures.<span class="pl-smi">TaskArg</span>{
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">1</span>,
        },
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">1</span>,
        },
    },
}

<span class="pl-smi">task2</span> <span class="pl-k">:=</span> signatures.<span class="pl-smi">TaskSignature</span>{
    <span class="pl-v">Name</span>: <span class="pl-s"><span class="pl-pds">"</span>add<span class="pl-pds">"</span></span>,
    <span class="pl-v">Args</span>: []signatures.<span class="pl-smi">TaskArg</span>{
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">5</span>,
        },
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">5</span>,
        },
    },
}

<span class="pl-smi">group</span> <span class="pl-k">:=</span> machinery.<span class="pl-c1">NewGroup</span>(&amp;task1, &amp;task2)
<span class="pl-smi">asyncResults</span>, <span class="pl-smi">err</span> <span class="pl-k">:=</span> server.<span class="pl-c1">SendGroup</span>(group)
<span class="pl-k">if</span> err != <span class="pl-c1">nil</span> {
    <span class="pl-c">// failed to send the group</span>
    <span class="pl-c">// do something with the error</span>
}</pre></div>

<p><code>SendGroup</code> returns a slice of <code>AsyncResult</code> objects. So you can do a blocking call and wait for the result of groups tasks:</p>

<div class="highlight highlight-go"><pre><span class="pl-k">for</span> <span class="pl-smi">_</span>, <span class="pl-smi">asyncResult</span> <span class="pl-k">:=</span> <span class="pl-k">range</span> asyncResults {
    <span class="pl-smi">result</span>, <span class="pl-smi">err</span> <span class="pl-k">:=</span> asyncResult.<span class="pl-c1">Get</span>()
    <span class="pl-k">if</span> err != <span class="pl-c1">nil</span> {
        <span class="pl-c">// getting result of a task failed</span>
        <span class="pl-c">// do something with the error</span>
    }
    fmt.<span class="pl-c1">Println</span>(result.<span class="pl-c1">Interface</span>())
}</pre></div>

<h3>
<a id="chords" class="anchor" href="#chords" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chords</h3>

<p><code>Chord</code> allows you to define a callback to be executed after all tasks in a group finished processing, e.g.:</p>

<div class="highlight highlight-go"><pre><span class="pl-k">import</span> (
    <span class="pl-s"><span class="pl-pds">"</span>github.com/RichardKnop/machinery/v1/signatures<span class="pl-pds">"</span></span>
    machinery <span class="pl-s"><span class="pl-pds">"</span>github.com/RichardKnop/machinery/v1<span class="pl-pds">"</span></span>
)

<span class="pl-smi">task1</span> <span class="pl-k">:=</span> signatures.<span class="pl-smi">TaskSignature</span>{
    <span class="pl-v">Name</span>: <span class="pl-s"><span class="pl-pds">"</span>add<span class="pl-pds">"</span></span>,
    <span class="pl-v">Args</span>: []signatures.<span class="pl-smi">TaskArg</span>{
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">1</span>,
        },
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">1</span>,
        },
    },
}

<span class="pl-smi">task2</span> <span class="pl-k">:=</span> signatures.<span class="pl-smi">TaskSignature</span>{
    <span class="pl-v">Name</span>: <span class="pl-s"><span class="pl-pds">"</span>add<span class="pl-pds">"</span></span>,
    <span class="pl-v">Args</span>: []signatures.<span class="pl-smi">TaskArg</span>{
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">5</span>,
        },
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">5</span>,
        },
    },
}

<span class="pl-smi">task3</span> <span class="pl-k">:=</span> signatures.<span class="pl-smi">TaskSignature</span>{
    <span class="pl-v">Name</span>: <span class="pl-s"><span class="pl-pds">"</span>multiply<span class="pl-pds">"</span></span>,
}

<span class="pl-smi">group</span> <span class="pl-k">:=</span> machinery.<span class="pl-c1">NewGroup</span>(&amp;task1, &amp;task2)
<span class="pl-smi">chord</span> <span class="pl-k">:=</span> machinery.<span class="pl-c1">NewChord</span>(group, &amp;task3)
<span class="pl-smi">chordAsyncResult</span>, <span class="pl-smi">err</span> <span class="pl-k">:=</span> server.<span class="pl-c1">SendChord</span>(chord)
<span class="pl-k">if</span> err != <span class="pl-c1">nil</span> {
    <span class="pl-c">// failed to send the chord</span>
    <span class="pl-c">// do something with the error</span>
}</pre></div>

<p>The above example execute task1 and task2 in parallel, aggregate their results and pass them to task3. Therefor what would end up happening is:</p>

<pre><code>multiply(add(1, 1), add(5, 5))
</code></pre>

<p>More explicitely:</p>

<pre><code>(1 + 1) * (5 + 5) = 2 * 10 = 20
</code></pre>

<p><code>SendChord</code> returns <code>ChordAsyncResult</code> which follows AsyncResult's interface. So you can do a blocking call and wait for the result of the callback:</p>

<div class="highlight highlight-go"><pre><span class="pl-smi">result</span>, <span class="pl-smi">err</span> <span class="pl-k">:=</span> chordAsyncResult.<span class="pl-c1">Get</span>()
<span class="pl-k">if</span> err != <span class="pl-c1">nil</span> {
    <span class="pl-c">// getting result of a chord failed</span>
    <span class="pl-c">// do something with the error</span>
}
fmt.<span class="pl-c1">Println</span>(result.<span class="pl-c1">Interface</span>())</pre></div>

<h3>
<a id="chains" class="anchor" href="#chains" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chains</h3>

<p><code>Chain</code> is simply a set of tasks which will be executed one by one, each successful task triggering the next task in the chain. E.g.:</p>

<div class="highlight highlight-go"><pre><span class="pl-k">import</span> (
    <span class="pl-s"><span class="pl-pds">"</span>github.com/RichardKnop/machinery/v1/signatures<span class="pl-pds">"</span></span>
    machinery <span class="pl-s"><span class="pl-pds">"</span>github.com/RichardKnop/machinery/v1<span class="pl-pds">"</span></span>
)

<span class="pl-smi">task1</span> <span class="pl-k">:=</span> signatures.<span class="pl-smi">TaskSignature</span>{
    <span class="pl-v">Name</span>: <span class="pl-s"><span class="pl-pds">"</span>add<span class="pl-pds">"</span></span>,
    <span class="pl-v">Args</span>: []signatures.<span class="pl-smi">TaskArg</span>{
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">1</span>,
        },
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">1</span>,
        },
    },
}

<span class="pl-smi">task2</span> <span class="pl-k">:=</span> signatures.<span class="pl-smi">TaskSignature</span>{
    <span class="pl-v">Name</span>: <span class="pl-s"><span class="pl-pds">"</span>add<span class="pl-pds">"</span></span>,
    <span class="pl-v">Args</span>: []signatures.<span class="pl-smi">TaskArg</span>{
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">5</span>,
        },
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">5</span>,
        },
    },
}

<span class="pl-smi">task3</span> <span class="pl-k">:=</span> signatures.<span class="pl-smi">TaskSignature</span>{
    <span class="pl-v">Name</span>: <span class="pl-s"><span class="pl-pds">"</span>multiply<span class="pl-pds">"</span></span>,
    <span class="pl-v">Args</span>: []signatures.<span class="pl-smi">TaskArg</span>{
        signatures.<span class="pl-smi">TaskArg</span>{
            Type:  <span class="pl-s"><span class="pl-pds">"</span>int64<span class="pl-pds">"</span></span>,
            Value: <span class="pl-c1">4</span>,
        },
    },
}

<span class="pl-smi">chain</span> <span class="pl-k">:=</span> machinery.<span class="pl-c1">NewChain</span>(&amp;task1, &amp;task2, &amp;task3)
<span class="pl-smi">chainAsyncResult</span>, <span class="pl-smi">err</span> <span class="pl-k">:=</span> server.<span class="pl-c1">SendChain</span>(chain)
<span class="pl-k">if</span> err != <span class="pl-c1">nil</span> {
    <span class="pl-c">// failed to send the chain</span>
    <span class="pl-c">// do something with the error</span>
}</pre></div>

<p>The above example execute task1, then task2 and then task3, passing result of each task to the next task in the chain. Therefor what would end up happening is:</p>

<pre><code>multiply(add(add(1, 1), 5, 5), 4)
</code></pre>

<p>More explicitely:</p>

<pre><code>((1 + 1) + (5 + 5)) * 4 = 12 * 4 = 48
</code></pre>

<p><code>SendChain</code> returns <code>ChainAsyncResult</code> which follows AsyncResult's interface. So you can do a blocking call and wait for the result of the whole chain:</p>

<div class="highlight highlight-go"><pre><span class="pl-smi">result</span>, <span class="pl-smi">err</span> <span class="pl-k">:=</span> chainAsyncResult.<span class="pl-c1">Get</span>()
<span class="pl-k">if</span> err != <span class="pl-c1">nil</span> {
    <span class="pl-c">// getting result of a chain failed</span>
    <span class="pl-c">// do something with the error</span>
}
fmt.<span class="pl-c1">Println</span>(result.<span class="pl-c1">Interface</span>())</pre></div>

<h2>
<a id="development-setup" class="anchor" href="#development-setup" aria-hidden="true"><span class="octicon octicon-link"></span></a>Development Setup</h2>

<p>First, there are several requirements:</p>

<ul>
<li>RabbitMQ</li>
<li>Go</li>
<li>Memcached (optional)</li>
</ul>

<p>On OS X systems, you can install them using Homebrew:</p>

<pre><code>$ brew install rabbitmq
$ brew install redis
$ brew install memcached
$ brew install go
</code></pre>

<p>Then get all Machinery dependencies.</p>

<pre><code>$ make deps
</code></pre>

<h3>
<a id="tests" class="anchor" href="#tests" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tests</h3>

<pre><code>$ make test
</code></pre>

<p>In order to enable integration tests, you will need to export few environment variables:</p>

<pre><code>$ export AMQP_URL=amqp://guest:guest@localhost:5672/
$ export MEMCACHE_URL=127.0.0.1:11211
$ export REDIS_URL=127.0.0.1:6379
</code></pre>

<p>I recommend to run the integration tests when making changes to the code. Due to Machinery being composed of several parts (worker, client) which run independently of each other, integration tests are important to verify everything works as expected.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/RichardKnop/machinery">Machinery</a> is maintained by <a href="https://github.com/RichardKnop">RichardKnop</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
